\TUchapter{Hybrid Extensions}
\TUsection{Introduction}
An objective of this thesis is to make the first known foray into the realm of
attack graphs with real-valued components. This chapter introduces the additional
modeling syntax and generation semantics required to permit real values for
qualities and topologies. Furthermore, some initial attempts at representing
the passage of time are described. 

Some of the requirements that this new hybrid scheme places on the modeler
have turned out to be more onerous than desired. However, since the use of 
attack graphs on hybrid systems with real valued properties is quite nascent, 
being introduced in this thesis, there is a significant contribution to their
study even in introducing less than ideal solutions to their inherent problems.

The ultimate goal of the specification of a hybrid attack graph for cyber
physical systems modeling must be the creation of a formalism capable of
modeling a network containing both traditional information systems (as
existing attack graph incarnations can) and hybrid systems (i.e. those that
can be modeled as hybrid automata). Therefore, the ideal hybrid attack graph
should be able to define systems (assets) that have some equivalence to a
hybrid automaton.

This thesis presents two novel attack graph elements with this requirement
in mind. The first is the ability to give both qualities and topologies
real (continuous domain) values, and correspondingly to permit exploits to
test and operate on these values in the expected ways with a full selection of
real-valued relational and assignment operators. These new types of facts are 
at the heart of this new model. 

The second contribution is modeling the progression
of time; as implemented in this thesis, time progression does not require any
new syntactic elements as compared to those provided in the discrete 
enhancements in the preceding chapter; those syntactic elements, however, are
used in a novel fashion to specify the
time evolution of quality and topology values.

The remainder of this chapter is structured as follows. First, the new
syntactic elements are introduced. Second, the semantic changes that these new
elements impose upon the generation process are described. Then the current
convention for the specification of time evolution is described. Next, 
time state aggregation, an enhancement for cognitive scalability purposes,
is introduced along with its semantic changes to the generation process.
Finally, a pair of examples are provided illustrating the ability of the
hybrid attack graph not only to capture cyber physical systems, but also to
enhanc the modeling capabilities of attack graphs for traditional information
systems.
\TUsection{Definition of New Syntax}
\TUsubsection{Terminology}
First and foremost, a discussion of the new terminology involved in the
transition to hybrid attack graphs is required. This is mostly concerned with
facts, as the movement to hybrid attack graphs is mostly concerned with changes
to the fact system.

Until now, qualities have had only string type values, and
topologies have had no values at all. In this chapter, that changes. Although
there will always remain a need for these discrete valued qualities and name
only topologies, there is also a need for qualities with 
continuous, numerical values. The introduction of a second type of quality
value is somewhat less jarring, however, than that of topologies with
values.

As the hybrid attack graph introduced by this thesis is a strict superset
of the University of Tulsa style discrete attack graph, the existing style
of quality and topology facts remains valid in the new language and therefore
must be distinguished from the new type of fact in some way. The discrete
only facts, therefore, are called \emph{token valued} (or \emph{token facts},
whereas the new continuous facts are called \emph{real valued} (or \emph{real
facts}).

% Additionally, later in this chapter another class of fact is introduced: a
% rate fact, which is a special case of a real fact. Rate facts are not a new
% syntactic element but are rather specified by convention and invoked by the
% new timing capability. TODO: this isn't true; add to future work.
\TUsubsection{Operators}
At the heart of the hybrid attack graph lies the new real facts. Their
existence marks the introduction of a true type system to the attack graph
model, which must be dealt with in some fashion. Furthermore, these new real 
facts demand new real operators to deal with them.

Typing is dealt with by ensuring that the sets of both assignment and relational
operators used for token and real facts are disjoint. While token qualities are
assigned with the \texttt{=} operator, real facts (both quality and topology)
are assigned using a \texttt{:=} operator.

As for the relational operators, token facts are tested using \texttt{=} 
and \texttt{!=}. The relational operators permitted for real facts (both
quality and topology) are different: \texttt{==}, \texttt{>}, \texttt{>=},
\texttt{<=}, and \texttt{<>} (for not equal).

Finally, because a principal property of real values is their suitability for
arithmetic, a number of new operators are introduced for use in exploit
postconditions only, with their straightforward C-like meanings: \texttt{:=},
\texttt{+=}, \texttt{-=}, \texttt{*=}, and \texttt{/=}. Note that currently
these operators take only literal reals as their second operand; variables
are not permitted.
\TUsubsection{Topology values}
Due to the usefulness of permitting real valued relationships between assets,
be they physical such as distance, or IT related like latency or signal
strength, in hybrid attack graphs, real topologies may take values. The
syntax for this is identical to the existing token topology syntax, except
followed by an operator and a number.

\TUsubsection{The update operation}
Because of the semantics of binary arithmetic operators such as \texttt{+=},
the term \texttt{insert} in postcondition operations is somewhat psychologically
unsatisfactory. Therefore, it is now aliased to \texttt{update}, a semantically
identical operation. In spite of its apparent redundancy, it provides for
future expansion as well as readability.
\TUsection{Time}
A fundamental requirement of modeling hybrid systems is the progression of
time, as the most interesting and distinctive properties of physical processes
are their evolution over time. Another goal is to avoid introducing additional
special cases. To that end, this section introduces a method for handling time
using only previously introduced attack graph functionality.
\TUsubsection{Time exploits}
Exploits are not just for adversary actions anymore. Time is implemented using
a single group of global exploits, each of which increments a class of assets'
position in time depending upon its particular state. The global status
causes them to trigger on all assets simultaneously, while the grouping causes
all the time exploits to trigger in concert with each other. As before,
an important requirement is that the sets of facts affected by time exploits
be disjoint over all grouped time exploits to avoid indeterminate behavior.

A selection of time exploits is provided in Fig.~\ref{fig:illustrative_time_xp}
of time exploits that might simplistically model
a car driving away from a wall unless somehow compromised by an attacker,
who causes the car to drive toward the wall at a constant rate.

\begin{figure}
\begin{lstlisting}
global group(time) exploit car_depart(c,w)=
    preconditions:
        platform:c,cpe:/h:honda:civic;
        quality:c,compromised != true;
        quality:w,wall=true;
        quality:c,status=up;
    postconditions:
        update topology:c<->w,distance+=25;
.

global group(time) exploit car_approach(c,w)=
    preconditions:
        platform:c,cpe:/h:honda:civic;
        quality:c,compromised=true;
        quality:w,wall=true;
        quality:c,status=up;
        topology:c<->w,distance>25;
    postconditions:
        update topology:c<->w,distance-=25;
.

global group(time) exploit car_crash(c,w)=
    preconditions:
        platform:c,cpe:/h:honda:civic;
        quality:c,compromised=true;
        quality:w,wall=true;
        quality:c,status=up;
        topology:c<->w,distance<=25;
    postconditions:
        update topology:c<->w,distance:=0;
        update quality:c,status=down;
.
\end{lstlisting}
\caption{Updated hybrid network state datatype pseudocode}
\label{fig:illustrative_time_xp}
\end{figure}

This method of modeling time requires time to be quantized and time stepping
behavior to be used.

\TUsection{Generation process changes}
\TUsubsection{Topologies}
Even without concern for real types, the move to hybrid attack graphs 
introduces a new, more basic requirement for the processing of preconditions
and postconditions: topology values. The topology fact handling is updated
to parallel the handling of qualities. In fact, in the hybrid attack graph
reference implementation, every topology, even token topologies, have values:
real topologies have floating-point values, and token topologies have boolean
values.

This results in the new factbase data structure provided in 
Fig.~\ref{fig:netstate_map_hybrid_pc}. The intermediate hash map representation
for topology facts is keyed on source asset names, with values that are
themselves hash maps keyed on destination asset names, with values that are
\emph{also} hash maps keyed on topology names, with values storing topology
values. Again, for token topologies, this value is always the boolean true.

\begin{figure}
\begin{lstlisting}
fact-tuple = ('quality', asset, name, value) or
           = ('topology', source, dest, name) or
           = ('platform', platform_part, ..., language)

type network_state:
    assets : set of strings;
    factbase : set of fact-tuples;
    qualities : map (keys=assets, vals=map(keys=quality_name,
                                           vals=quality_value))
    topologies : map (keys=src_assets, vals=map(keys=dest_asset,
                                                vals=map(keys=topology,
                                                         vals=values))
\end{lstlisting}
\caption{Updated hybrid network state datatype pseudocode}
\label{fig:netstate_map_hybrid_pc}
\end{figure}
\TUsubsection{Matching}
With the introduction of new relational operators, significantly more advanced
precondition processing than strict matching. Happily, the changes introduced
in the previous chapter anticipated this, so the heavy lifting required for
fact value lookup already exists. All that remains is the mapping of the
parsed attack graph operators onto implementation operators in the generation
software.

As illustrated in the pseudocode in Fig.~\ref{fig:hybrid-matching}, this is
done in the reference implementation by maintaining a map from the string
representations of the relational operators onto boolean functions that apply
them. The new relational operator precondition processing does not impact the
remainder of the generation process.

\begin{figure}
\begin{lstlisting}
RELOPS = map(keys = ('==', '<>', '>=', '<=', '<', '>', '=', '!=',
             vals = (associated functions))
             
def matches_topology(source, dest, name, value=True, op='==',
                     check_reverse=False):
    if source in factbase.topologies and
      dest in factbase.topologies[source] and
      name in factbase.topologies[source][dest]:
        my_value = factbase.topologies[source][dest][name]
    else:
        return False

    if type(my_value) != type(value):
        Error: Cannot match token values with real values.
    
    if check_reverse:
        return RELOPS[op](my_value, value) and
               matches_topology(dest, source, name, value=value,
                                op=op)
    else:
        return RELOPS[op](my_value, value)

def matches_quality(asset, name, value, op='=='):
    if asset in factbase.qualities and
      name in factbase.qualities[asset]:
        my_value = factbase.qualities[asset][name]
    else:
        return False
    
    if type(my_value) != type(value):
        Error: Cannot match token values with real values.
    
    return RELOPS[op](my_value, value)
\end{lstlisting}
\caption{Hybrid precondition matching pseudocode}
\label{fig:hybrid-matching}
\end{figure}
\TUsubsection{Updating}
The hybrid attack graph includes assignment operators that require new
postcondition handling that closely parallels their precondition handling.
The same issues are addressed here; value querying and setting is already
handled, but operator selection is not. The pseudocode for this process is
presented in Fig.~\ref{fig:hybrid-postcondition}.

\begin{figure}
\begin{lstlisting}
ASSIGNOPS = map(keys=('+=', '-=', '*=','/=', ':=', '='),
                vals=(associated functions)

def set_quality(factbase, asset, name, value, op='='):
    if asset in factbase.qualities and
      name in factbase.qualities[asset]:
        my_value = factbase.qualities[asset][name]
    else:
        my_value = 0
    new_value = ASSIGNOPS[op](my_value, value)
    update factbase with:
        factbase.qualities[asset][name] = new_value

def set_topology(factbase, source, dest, name, value=True, op=None):
    if not op: # Token
        update factbase with:
            factbase.topologies[source][dest][name] = value
    else: # Real
        if source in factbase.topologies and
          dest in factbase.topologies[source] and
          name in factbase.topologies[source][dest]:
            my_value = self.assets[source].get_topology(dest, name)
        else:
            my_value = 0
        new_value = ASSIGNOPS[op](my_value, new_value)
        update factbase with:
        factbase.qualities[source][dest][name] = new_value
\end{lstlisting}
\caption{Hybrid postcondition application pseudocode}
\label{fig:hybrid-postcondition}
\end{figure}
\TUsection{Examples}
\TUsubsection{Denial of Sleep}

\TUsubsection{Automobile}