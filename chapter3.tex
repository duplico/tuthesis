\TUchapter{Attack Graphs}
\TUsection{Introduction}
This chapter presents a version of the attack graph modeling framework specific
to traditional information systems. The framework has a very permissive model that
includes notions of assets, qualities, topologies. Assets represent potentially
attackable system components; qualities assign an arbitrary string value to a named
property of an asset, and topologies bind pairs of assets together with a named
connection between them. Exploit patterns with preconditions and postconditions attached
to free variables that can be bound at generation time to assets serve to describe potential
state transitions. The next section contains a more formal definition of the basic
framework.

Because of the extremely permissive model for naming properties and topologies in this
scheme, the modeler must fix a lexicon of terms and their meanings in order to proceed
systematically. Section 3 of this chapter presents a preliminary version of such a lexicon,
fixing enough terminology to proceed with the case studies.

Research into attack graphs can be split into four broad categories:
\begin{description}
\item[Modeling] Attack graph modeling concerns the development of the underlying representation
	and use of that representation to model systems. Terminology belongs here, as do efforts to
	automatically generate network models from real networks and exploit patterns from vulnerability
	databases.
\item[Generation] Attack graph generation is the process of building a graph out of a model by
	closing the state space over its exploits. This is where most performance work is concentrated.
	A good portion of the work that enables a representation of time to be included in attack graphs
	belongs here as well. Constraints (such as monotonicity) on the way that state transitions are 
	allowed to progres also fall under the generation category.
\item[Analysis] Analysis of attack graphs focuses on drawing conclusions about a system based upon
	the attack graph generated from its model. Work here includes integration with intrusion detection
	systems, automatic delivery of mitigation recommendations, and the identification of security
	consequences with particular states.
\item[Visualization] Visualization of attack graphs seeks to reduce or eliminate their
	known cognitive scalability issues; the goal is to deliver the results of the other three
	steps in a meaningful fashion.
\end{description}
This thesis is mainly concerned with the modeling stage, its goal being to introduce an
architecture for modeling hybrid systems with attack graphs. However, some amount of work is
included in the generation stage, particularly some thoughts on dealing with the progression
of time; consideration is also given to analysis, particularly on identifying failure states and
on aggregating sufficiently similar states (which also touches visualization).

Sections 4 and 5 introduce two analysis tools for attack graphs: state predicates and state
aggregation. State predicates are logical predicates concerning a network state that could
be used to specify particular failure cases, nominal system behavior, operating modes,
or similarity conditions that permit states to be visually grouped due to some shared characteristics.
This concept is necessary to allow the following chapter's introduction of time to be tractable.
\TUsection{Definition}
\TUsubsection{Intuitive}
For the purposes of this work, an attack graph is comprised of the following components.
\begin{description}
	\item[Assets] Assets are the subjects in the attack graph formalism, mainly representing
		attackable system components. For example, in a model of the RFID denial of sleep
		attack, the assets are the RFID tags, the reader, the possible rogue reader,
		and any hosts connected over the network with the RFID reader. Assets are specified
		with unique names, and they are decorated with \emph{qualities} and \emph{topologies}.
		Assets can also be used to model users and adversaries if it is necessary to give them
		explicit properties. A model's collection of assets is fixed at definition time and
		is not changed by state transitions.
	\item[Qualities] Qualities represent properties of an asset, such as a software package or
		version that is installed, whether it is in sleep mode or not, and so on. Qualities are
		can be considered a key/value pair, where both the key and the value are string tokens. For
		example, the \texttt{host1} asset may have the quality \texttt{power} and the value \texttt{on}.
		Together with topologies, qualities make up the collection of facts.
	\item[Topologies] Topologies represent relationships between two assets. These can be physical such
		as denoting that a printer is plugged into a computer, logical such as denoting that one
		host is accessible from another on an adjacent network, or more abstract such as a particular
		trust relationship or level of access that a subject has on another. Topologies are directed and
		named with string tokens. For example, \texttt{host1} might be accessible over the network via the
		web by \texttt{host2}, so a directed topology from \texttt{host2} to \texttt{host1} called
		\texttt{network\_remote\_web} might be used. Together with qualities, topologies make up the
		network state's collection of facts.
	\item[State] A network or system state is comprised of all of the facts about the system's asset
		collection. A network model's state is fully described by the asset collection and the fact base;
		given the constant asset collection, a state is uniquely described by its fact base. The fact
		base is all the qualities and topologies that are valid for that state.
	\item[Exploit patterns] Exploit patterns are generalized templates for how the actions of the attacker
		can alter the system state by inserting and removing qualities and topologies (but not assets).
		They are written as functions that take a number of parameters corresponding to assets, mapping
		a set of preconditions (facts about the free asset parameters) to a set of postconditions:
		insert and delete actions on qualities and topologies to update the fact base and therefore
		generate a new network state.
\end{description}
\TUsubsection{Formal}
\TUsubsubsection{Primitive Domains}
In order to provide a more formal description of the attack graph modeling framework,
it is necessary to fix first the domains of note. The primitive domains are the most basic 
domains that describe the atomic units of
the formalism: assets, properties (qualities), values (qualities), relationships (topologies),
vulnerabilities (exploit pattern identifiers), and parameters (free asset variables in the attack
patterns), and operations (used in postconditions representing insert or delete actions):
\begin{align*}
    \mathcal{A} :& \text{assets} \\
    \mathcal{P} :& \text{properties (quality names)} \\
    \mathcal{V} :& \text{values (property values)} \\
    \mathcal{R} :& \text{relationships (topology names)} \\
    \mathcal{W} :& \text{vulnerabilities (exploit pattern names)} \\
    \mathcal{I} :& \text{parameters (free asset names)} \\
    \text{Op} =& \left\{\text{ins}, \text{del} \right\}
\end{align*}

\TUsubsubsection{Compound Domains}
Compound domains comprise the fundamental concepts that are composed of combinations
of members of the primitive domains. These form the level of abstraction that it is
most convenient to discuss in the articulation of the execution model and in the
preceding intuitive definition, for instance.
\begin{description}
    \item[Qualities] Qualities bind an asset to a property to a value; therefore their
        domain is the cartesian product of those domains. The $n$ subscripts denote that
        these are bound qualities of a network state, rather than free qualities in
        exploit preconditions and postconditions:
        \begin{align*}
            \mathcal{Q}_n &: \mathcal{A} \times \mathcal{P} \times \mathcal{V}
        \end{align*}
    \item[Topologies] Topologies bind an asset to another asset through a relationship; therefore their
        domain is the cartesian product of those domains:
        \begin{align*}
            \mathcal{T}_n&: \mathcal{A} \times \mathcal{A} \times \mathcal{R}
        \end{align*}
    \item[Network states] A network state, then, is denoted by a collection of assets, and a fact base
        of qualities and topologies; the domain of a network state is the cartesian product
        of the power sets of these domains:
        \begin{align*}
            \mathcal{N}&: \mathbb{P}(\mathcal{A}) \times \mathbb{P}(\mathcal{Q}_n) \times \mathbb{P}(\mathcal{T}_n)
        \end{align*}
    \item[Exploit patterns] Exploit patterns, taken from the domain $\mathcal{E}$ 
		depend upon free versions of qualities and topologies,
		which are parameterized by members of $\mathcal{I}$ rather than $\mathcal{A}$, which are used in
		preconditions and, when combined with an operator, postconditions:
        \begin{align*}
			\mathcal{Q}_e&: \mathcal{I} \times \mathcal{P} \times \mathcal{V} \\
			\mathcal{T}_e&: \mathcal{I} \times \mathcal{I} \times \mathcal{R} \\
			\text{Preconditions } \mathcal{P}rc_e &: \mathbb{P}(\mathcal{Q}_e) \times \mathbb{P}(\mathcal{T}_e) \\
			\text{Postconditions } \mathcal{P}oc_e&: \mathbb{P}((Op,\mathcal{Q}_e)) \times \mathbb{P}((Op,\mathcal{T}_e)) \\
			\mathcal{E}&: \mathcal{W} \times \vec{\mathcal{I}} \times  \mathcal{P}rc \times \mathcal{P}oc
        \end{align*}
    \item[Attacks] An exploit pattern whose parameters have been bound to assets is referred to as an
		attack. It takes a similar appearance:
		\begin{align*}
			\text{Preconditions } \mathcal{P}rc_n &: \mathbb{P}(\mathcal{Q}_n) \times \mathbb{P}(\mathcal{T}_n) \\
			\text{Postconditions } \mathcal{P}oc_n&: \mathbb{P}((Op,\mathcal{Q}_n)) \times \mathbb{P}((Op,\mathcal{T}_n)) \\
			\mathcal{X}&: \mathcal{W} \times \vec{\mathcal{I}} \times  \mathcal{P}rc \times \mathcal{P}oc
        \end{align*}
\end{description}
% TODO - fill in the rest of this.
\TUsection{Execution Model}
\TUsubsection{Introduction}
The reference implementation of this thesis's attack graph execution model does not use this
formal notation to represent system elements, instead favoring a more user friendly specification
language. % Todo: name it? :)
\TUsubsection{Network Model Specification}
\TUsubsection{Exploit Specification}
\TUsubsection{Generation Process}
\TUsubsection{Output}
\TUsection{Working Lexicon}
\TUsubsection{Introduction}
\TUsubsection{National Vulnerability Database}
\TUsubsubsection{Access vector}
\TUsubsubsection{Status}
\TUsubsubsection{Type}
\TUsubsection{Qualities}
\TUsubsection{Topologies}
\TUsection{Examples}
\TUsubsection{Blunderdome}
\TUsubsection{Denial of Sleep}
\TUsection{State Predicates}
\TUsection{State Aggregation}